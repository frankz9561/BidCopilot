# 标书生成工具 - 最终架构设计方案

> **架构目标**：构建一个本地优先、安全可控、高性能的智能标书生成桌面应用  
> **技术栈**：Electron + Vue 3 + TypeScript（前端）+ Python FastAPI（后端）  
> **架构理念**：结构化设计、渐进增强、实用主义、安全第一

---

## 一、架构设计理念与原则

### 1.1 核心设计理念

#### 从三种方案中提炼的核心价值

**来自 OpenAI 方案的精华**：
- **结构化与可验证性**：架构设计必须可量化、可验证、可追溯
- **模块化思维**：将复杂系统拆解为独立的、职责明确的模块
- **安全边界明确**：渲染层不可信、主进程和 Python 后端为可信执行单元
- **非功能需求优先**：性能、安全、可维护性等 NFR 与功能需求同等重要

**来自 Gemini 方案的精华**：
- **实战导向**：关注具体技术实现细节和常见痛点
- **分阶段迭代**：顶层架构 → 数据层 → 核心功能 → 工程化打包
- **进程协调**：Electron 与 Python 的进程模型和生命周期管理
- **用户体验**：流式输出、实时反馈、优雅降级

**来自 Claude 方案的精华**：
- **全栈视角**：从前端到后端、从开发到运维的完整技术链路
- **工程化实践**：代码规范、测试覆盖、CI/CD、性能优化
- **可维护性**：清晰的目录结构、统一的错误处理、完善的日志体系
- **开发效率**：脚手架模板、组件库、工具函数的系统化管理

### 1.2 架构设计原则

#### 1. 安全性原则（Security First）

**信任边界划分**：
```
┌─────────────────────────────────────────────────┐
│ 渲染进程（Renderer）- 不可信区域                  │
│ - 不存储密钥和敏感数据                           │
│ - 不直接访问文件系统和数据库                      │
│ - 所有特权操作通过 IPC 请求主进程                │
└─────────────────────────────────────────────────┘
                    ↕ IPC (preload.js)
┌─────────────────────────────────────────────────┐
│ 主进程（Main Process）- 半可信区域               │
│ - 管理窗口生命周期                               │
│ - 代理 Python 后端通信                          │
│ - 处理文件对话框和系统集成                       │
└─────────────────────────────────────────────────┘
                    ↕ HTTP/JSON-RPC/stdio
┌─────────────────────────────────────────────────┐
│ Python 后端（FastAPI）- 可信执行单元             │
│ - 持有 API 密钥（加密存储）                      │
│ - 执行 RAG 检索和模型调用                        │
│ - 访问本地数据库和文件系统                       │
└─────────────────────────────────────────────────┘
```

**安全策略**：
- 密钥管理：使用操作系统级别的安全存储（Windows Credential Manager / macOS Keychain）
- IPC 防护：发送方验证、消息签名、最小权限原则
- 数据隐私：本地数据不外传，仅发送必要的上下文给云端模型
- 审计日志：关键操作（文档导入、模型调用、数据导出）记录审计日志

#### 2. 性能原则（Performance Budgets）

**量化性能指标**（继承自 OpenAI 方案）：
| 指标 | 目标值 | 优先级 | 测量方法 |
|------|--------|--------|----------|
| 冷启动时间 | ≤ 5s | P0 | 从点击图标到主界面可交互 |
| Python 后端就绪 | ≤ 3s | P0 | 后台异步加载，不阻塞 UI |
| 本地检索延迟 | P95 ≤ 300ms | P0 | 从查询到结果返回 |
| 首 token 生成 | ≤ 3s | P1 | 依赖云端模型延迟 |
| 大文档预览 | 首屏 ≤ 200ms | P1 | 虚拟滚动、分段渲染 |
| 内存占用 | ≤ 1.5GB | P1 | 正常工作负载下 |
| 安装包体积 | ≤ 500MB | P2 | 含 Python 运行时 |

**性能策略**：
- 前端：虚拟列表、懒加载、组件异步加载、Memoization
- 后端：向量索引优化、LRU 缓存、连接池复用
- 通信：流式传输、增量更新、批量操作

#### 3. 可维护性原则（Maintainability）

**模块化分层**：
```
前端（Vue 3 + TypeScript）
├── 展示层（Views）：页面级组件
├── 业务层（Components）：业务组件
├── 状态层（Stores）：Pinia 状态管理
├── 接口层（API）：与后端通信
└── 工具层（Utils）：通用工具函数

后端（Python FastAPI）
├── API 层（Routers）：路由和请求处理
├── 服务层（Services）：业务逻辑编排
├── 领域层（Domain）：核心业务模型
├── 数据层（Repositories）：数据访问抽象
└── 适配层（Adapters）：外部依赖适配（向量库、LLM）
```

**代码质量保障**：
- 前端：ESLint + Prettier + TypeScript 严格模式
- 后端：Ruff + Black + MyPy + Pydantic 验证
- 测试：单元测试覆盖率 ≥ 80%、关键路径 E2E 测试
- 文档：API 文档自动生成（OpenAPI）、架构决策记录（ADR）

#### 4. 渐进增强原则（Progressive Enhancement）

**开发优先级**（借鉴 Gemini 的分阶段思路）：

**第一阶段：核心骨架（Week 1-2）**
- [ ] 进程模型：Electron 启动、Python 子进程管理、IPC 通信
- [ ] 基础 UI：主窗口、侧边栏、顶部导航
- [ ] 健康检查：前后端心跳、异常重启机制

**第二阶段：数据管线（Week 3-4）**
- [ ] 文档导入：PDF/Word 解析、文本提取
- [ ] 向量化：分块策略、Embedding 生成、LanceDB 存储
- [ ] 检索引擎：向量检索 + 关键词检索（混合检索）

**第三阶段：生成功能（Week 5-6）**
- [ ] 模型集成：OpenAI-compatible 接口、流式输出
- [ ] 提示词工程：系统提示词、Few-shot 示例、引用格式化
- [ ] Word 生成：docxtpl 模板引擎、动态填充

**第四阶段：打磨与交付（Week 7-8）**
- [ ] 打包优化：PyInstaller 构建、Electron Builder 配置
- [ ] 自动更新：版本检查、增量更新、回滚机制
- [ ] 用户文档：使用手册、故障排查指南

---

## 二、系统架构设计

### 2.1 整体架构视图

```
┌─────────────────────────────────────────────────────────────────┐
│                     桌面应用外壳 (Electron)                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  渲染进程 (Renderer - Vue 3 + TypeScript)                │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐  │   │
│  │  │项目工作台│ │合规矩阵  │ │生成审阅  │ │模板设置  │  │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘  │   │
│  │  ┌───────────────────────────────────────────────────┐ │   │
│  │  │           Pinia Store (状态管理)                   │ │   │
│  │  └───────────────────────────────────────────────────┘ │   │
│  │  ┌───────────────────────────────────────────────────┐ │   │
│  │  │           API Client (axios)                       │ │   │
│  │  └───────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
│                          ↕ IPC (preload.js)                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  主进程 (Main Process - Node.js)                        │   │
│  │  - 窗口管理                                             │   │
│  │  - Python 子进程生命周期管理                            │   │
│  │  - 文件系统访问代理                                     │   │
│  │  - 系统托盘和通知                                       │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                          ↕ HTTP REST (127.0.0.1:8765)
┌─────────────────────────────────────────────────────────────────┐
│              Python 本地后端 (FastAPI - 子进程)                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  API 层 (FastAPI Routers)                               │   │
│  │  /api/v1/projects | /documents | /requirements          │   │
│  │  /api/v1/generation | /review | /templates | /health    │   │
│  └─────────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  服务层 (Business Logic)                                │   │
│  │  DocumentService | RetrievalService | GenerationService │   │
│  │  ComplianceService | ReviewService | TemplateService    │   │
│  └─────────────────────────────────────────────────────────┘   │
│  ┌──────────────┐ ┌──────────────┐ ┌───────────────────┐     │
│  │ SQLite 元数据 │ │ LanceDB 向量 │ │ 文件存储 (本地)   │     │
│  └──────────────┘ └──────────────┘ └───────────────────┘     │
└─────────────────────────────────────────────────────────────────┘
                          ↕ HTTPS
                    ┌─────────────────┐
                    │  云端 LLM 模型   │
                    │  (OpenAI API)   │
                    └─────────────────┘
```

### 2.2 核心技术决策（ADR 摘要）

#### ADR-001: Electron 与 Python 通信方案

**问题**：前后端进程如何通信？

**备选方案**：
| 方案 | 优势 | 劣势 | 适用场景 |
|------|------|------|----------|
| A. stdio JSON-RPC | 无端口占用、简单安全 | 调试困难、不支持并发请求 | 简单应用 |
| B. HTTP REST (127.0.0.1) | 调试友好、工具生态成熟 | 需端口协商、有被本地攻击风险 | **推荐方案** |
| C. gRPC | 高性能、类型安全 | 复杂度高、打包体积大 | 高性能场景 |
| D. WebSocket | 双向通信、实时推送 | 过度设计 | 实时协作场景 |

**决策**：选择 **HTTP REST (127.0.0.1)**

**理由**：
1. 开发体验：Postman/curl 测试、浏览器 DevTools 调试
2. 生态成熟：FastAPI 自动生成 OpenAPI 文档
3. 安全可控：动态端口分配（8765-8775 范围）、启动时生成临时 token
4. 性能足够：本地回环接口延迟 < 5ms

**风险缓解**：
- 端口冲突：启动时动态探测可用端口，写入临时文件由主进程读取
- 本地攻击：生成随机 token（UUID），所有请求需携带 `X-Local-Token` Header
- 防火墙：仅监听 127.0.0.1，不暴露外网

**实现要点**：
```
主进程启动逻辑：
1. spawn Python 子进程：python backend/main.py --port 0 (0 表示自动分配)
2. Python 启动后将实际端口写入 stdout：{"port": 8765, "token": "xxx"}
3. 主进程解析 stdout，将 port 和 token 注入渲染进程环境变量
4. 渲染进程所有请求自动携带 token
```

#### ADR-002: 向量数据库选型

**问题**：本地向量检索用什么数据库？

**备选方案**：
| 方案 | 嵌入式 | 性能 | 打包难度 | 生态 |
|------|--------|------|----------|------|
| LanceDB | ✅ | 高 | 低 | ⭐⭐⭐⭐ |
| Chroma | ✅ | 中 | 中 | ⭐⭐⭐⭐ |
| Qdrant (embedded) | ✅ | 高 | 高（Rust 依赖） | ⭐⭐⭐ |
| sqlite-vec | ✅ | 低 | 低 | ⭐⭐ |

**决策**：选择 **LanceDB**

**理由**：
1. 桌面友好：纯 Python 实现（基于 PyArrow），无需额外二进制依赖
2. 性能优秀：列式存储、SIMD 加速、支持百万级向量毫秒级检索
3. 易于打包：PyInstaller 可直接打包，无需特殊配置
4. 迁移友好：数据存储为 .lance 文件，用户可轻松备份和迁移

**数据模型设计**：
```python
# LanceDB Schema
class DocumentChunk(LanceModel):
    id: str                                    # chunk_uuid
    doc_id: str                                # 文档 ID
    doc_name: str                              # 文档名称
    chunk_index: int                           # 分块序号
    text: str                                  # 原始文本
    vector: Vector(1536)                       # Embedding 向量
    metadata: dict                             # 扩展元数据
    created_at: datetime                       # 创建时间
```

#### ADR-003: Python 后端打包方案

**问题**：如何将 Python 代码和依赖打包到桌面应用中？

**备选方案**：
| 方案 | 体积 | 启动速度 | 维护成本 |
|------|------|---------|----------|
| PyInstaller (单文件) | 大 (~400MB) | 慢（需解压） | 低 |
| PyInstaller (目录模式) | 中 (~300MB) | 快 | 低 |
| PyOxidizer | 小 | 最快 | 高（Rust 生态） |
| 嵌入 Python 解释器 | 可控 | 快 | 高（需手动管理依赖） |

**决策**：选择 **PyInstaller 目录模式**

**理由**：
1. 成熟稳定：经过大量项目验证，坑已知且可规避
2. 启动快：目录模式无需解压，冷启动 < 3s
3. 易调试：目录结构清晰，可直接查看依赖树
4. 易更新：可仅替换 Python 后端目录，不需重新安装整个应用

**极致优化策略**：
```
剪裁无关依赖：
- 排除 Jupyter、IPython、matplotlib、pandas（如果不用）
- 使用 pipreqs 精确分析实际依赖
- 多阶段构建：先构建轻量基础镜像，再添加业务代码

预期体积：
- Python 运行时 + FastAPI + LanceDB + OpenAI SDK: ~200MB
- 向量数据（用户数据）: ~10GB（5000 文档 * 2MB）
```

#### ADR-004: 提示词工程架构

**问题**：如何管理和迭代提示词？

**决策**：采用 **提示词模板化 + 版本控制 + A/B 测试** 架构

**实现架构**：
```
backend/prompts/
├── registry.yaml               # 提示词注册表
├── templates/
│   ├── system/
│   │   ├── base.txt            # 基础系统提示词
│   │   └── expert_role.txt     # 专家角色定义
│   ├── generation/
│   │   ├── technical.txt       # 技术方案生成
│   │   ├── commercial.txt      # 商务条款生成
│   │   └── pricing.txt         # 报价表生成
│   └── retrieval/
│       ├── rerank.txt          # 重排序提示词
│       └── summary.txt         # 摘要生成
└── versions/
    └── v1.0.0/                 # 历史版本归档
```

**四层提示词结构（与产品设计对齐）**：
1. **Global Guardrails**：安全、引用、格式约束  
2. **Task Instruction**：当前任务目标与验收标准  
3. **Business Context**：项目背景、模板规范、写作风格  
4. **Evidence Pack**：检索证据（含 chunk_id 与来源）  

**提示词模板示例**：
```jinja2
{# templates/generation/technical.txt #}
你是一位资深的{{domain}}领域专家，正在为"{{project_name}}"项目编写技术方案。

【背景资料】
{{retrieved_context}}

【生成要求】
1. 技术路线清晰，层次分明
2. 引用背景资料时标注来源（使用 [来源: {{doc_name}}] 格式）
3. 篇幅控制在 {{word_count}} 字以内
4. 语言专业、严谨、符合标书规范

【输出格式】
按以下结构输出：
## 技术方案概述
## 技术架构设计
## 关键技术路线
## 风险控制措施
```

**版本管理策略**：
- 所有提示词变更记录 Git 提交历史
- 每次发版打 tag（如 prompts-v1.2.0）
- 生成结果记录使用的提示词版本（用于回溯和对比）
- 关键提示词支持 A/B 测试与效果评估

---

## 三、关键子系统设计

### 3.1 进程管理与生命周期

#### 3.1.1 启动流程（优雅启动）

```
用户双击图标
    ↓
Electron 主进程启动
    ↓
├─→ 创建主窗口（隐藏）
│   └─→ 加载 Loading 页面
│
├─→ 启动 Python 子进程（异步）
│   ├─→ 检测可用端口（8765-8775）
│   ├─→ 生成临时 token
│   ├─→ 启动 FastAPI uvicorn
│   └─→ 等待健康检查通过（/api/health）
│           ↓
│       成功：写入端口和 token 到共享内存
│       失败：重试 3 次 → 显示错误页面
│
└─→ 初始化完成后
    ├─→ 注入环境变量到渲染进程
    ├─→ 显示主窗口
    └─→ 渲染进程开始正常工作

总耗时目标：< 5s
```

#### 3.1.2 关闭流程（优雅关闭）

```
用户关闭窗口 / Cmd+Q / Alt+F4
    ↓
主进程接收 window-close 事件
    ↓
1. 通知 Python 后端准备关闭
   └─→ POST /api/admin/shutdown
       ├─→ 保存未完成的任务状态
       ├─→ 关闭数据库连接
       └─→ 返回 OK
    ↓
2. 发送 SIGTERM 给 Python 子进程
   └─→ 等待最多 5s
       ↓
   未响应 → 发送 SIGKILL 强制终止
    ↓
3. 清理临时文件
   └─→ 删除 token 文件、日志锁
    ↓
4. 退出主进程

防僵尸进程策略：
- 主进程退出时强制清理所有子进程（通过 PID 文件）
- 定时心跳检测（每 30s ping 一次）
- Python 进程超时未响应自动重启
```

### 3.2 文档处理与 RAG 检索管线

#### 3.2.1 文档导入流程

```
用户上传文档（PDF/Word）
    ↓
┌─────────────────────────────────────────┐
│ 1. 文件解析 (Document Parser)            │
│    - PDF: PyMuPDF + pdfplumber（表格/分页）│
│    - Word: python-docx                  │
│    - 提取文本 + 元数据（标题、页码、表格）│
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│ 2. 智能分块 (Chunking)                  │
│    策略: 基于语义层级的混合分块          │
│    - Chunk Size: 700 tokens            │
│    - Overlap: 120 tokens               │
│    - 特殊处理：表格保持完整、代码块不拆分 │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│ 3. 向量化 (Embedding)                   │
│    - 模型: text-embedding-3-small       │
│    - 批量处理: 每批 100 个 chunk        │
│    - 缓存策略: 相同文本命中缓存无需重复  │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│ 4. 存储 (Dual Storage)                  │
│    - LanceDB: 存储向量 + chunk 文本     │
│    - SQLite: 存储元数据（文档信息、状态）│
│    - 文件系统: 存储原始文件备份          │
└─────────────────────────────────────────┘
    ↓
完成，通知前端更新文档列表
```

**核心优化**：
- **增量导入**：已导入文档的 hash 值存储，相同文档跳过
- **断点续传**：大文档分批处理，记录进度，失败可恢复
- **并发控制**：最多同时处理 3 个文档，避免 CPU 和内存爆炸

#### 3.2.2 招标文件结构化解析与合规矩阵

**目标**：从 RFP/招标文件提取“需求条款 + 评分点 + 风险条款”，形成可执行的合规矩阵。  

**流程**：
1. **结构化解析**：识别标题层级、编号规则、表格与附件  
2. **规则 + LLM 混合抽取**：输出 `requirements[] / scoring_points[] / risk_flags[]`  
3. **需求条款落库**：生成 `requirement_id`，记录 `source_chunk_ids` 便于引用追溯  
4. **问题清单**：输出 `open_questions[]`（资料不足项）供用户补充  

**关键点**：
- 表格/清单类需求优先走 pdfplumber/camelot 结构化解析  
- 支持 **Parent Document Retriever**：chunk 关联 `parent_section_id`，保证检索时保留完整上下文  

#### 3.2.3 Query Pack 与 Evidence Pack

**Query Pack 生成**：
- 每条需求生成多路查询：关键词/编号/同义词/英文别名  
- 输出 `must_have_evidence_types`（必备证据类型，如资质、案例、参数表）  

**Evidence Pack 结构**：
```
{
  "chunk_id": "c_123",
  "doc_id": "d_456",
  "page": 12,
  "score": 0.86,
  "tags": ["资质", "性能指标"],
  "snippet": "..."
}
```

**证据选择与陈述计划**：
- Top-K 证据 → 重排序 → 形成 `claim_plan`  
- 标记缺口：对无法覆盖的需求输出 `gaps[]`，避免编造  

#### 3.2.4 混合检索策略

**问题**：向量检索对专有名词（如项目编号、公司名）召回率低

**解决方案**：向量检索（语义相似） + BM25 检索（关键词匹配）混合

```python
# 伪代码逻辑
async def hybrid_search(query: str, top_k: int = 10):
    # 1. 向量检索
    query_vector = await embedding_model.encode(query)
    vector_results = await lancedb.search(query_vector, top_k=20)
    
    # 2. BM25 关键词检索
    bm25_results = await bm25_index.search(query, top_k=20)
    
    # 3. 重排序 (RRF - Reciprocal Rank Fusion)
    merged = rrf_merge(vector_results, bm25_results, k=60)
    
    # 4. 返回 Top-K
    return merged[:top_k]
```

**性能基准**：
- 纯向量检索：P95 延迟 < 200ms
- 混合检索：P95 延迟 < 300ms（增加 BM25 开销）
- 召回率提升：+15%（针对专有名词场景）

### 3.3 生成引擎与流式输出

#### 3.3.1 分阶段生成与证据链路

**核心原则**：遵循“解析 → 规划 → 检索 → 草拟 → 校验 → 定稿”的链式流程，确保内容可追溯、可审阅。  

**阶段产物**：
1. **合规矩阵**：requirements / scoring_points / risk_flags  
2. **Query Pack**：多路检索查询 + 必备证据类型  
3. **Evidence Pack**：Top-K 证据片段 + 可信度 + 来源  
4. **Claim Plan**：陈述点 ↔ 证据映射 + 缺口标记  
5. **Draft**：强制引用 + 假设/待确认清单  
6. **Review Report**：缺引用 / 弱引用 / 超承诺 / 风险提示  

#### 3.3.2 生成管线设计

```
用户输入生成需求
    ↓
┌─────────────────────────────────────────┐
│ 1. 任务识别 (Task Classification)        │
│    - 关联需求条款/章节（来自合规矩阵）  │
│    - 提取关键参数：项目名、预算、工期   │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│ 2. 证据检索 (Evidence Retrieval)         │
│    - 生成 Query Pack                    │
│    - 混合检索获取 Top-K 证据片段         │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│ 3. 陈述计划 (Claim Plan)                 │
│    - 证据选择与缺口标注                  │
│    - 每条陈述绑定 chunk_id               │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│ 4. 提示词构建 (Prompt Engineering)       │
│    - 全局约束 + 任务指令 + 业务上下文    │
│    - Evidence Pack 注入（含 chunk_id）   │
│    - 长度优化：确保 context < 6000 tokens│
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│ 5. 模型调用 (LLM Inference)              │
│    - 流式调用 OpenAI-compatible API     │
│    - SSE 推送前端                        │
│    - 支持中途取消                         │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│ 6. 后处理 (Post-Processing)              │
│    - 引用归一化：chunk_id ↔ 文档/页码     │
│    - 格式校验：JSON/结构化输出校验        │
│    - 质量检查：缺引用/超承诺/风险提示     │
└─────────────────────────────────────────┘
    ↓
返回 Draft + Citation Map + Review Report
```

#### 3.3.3 流式输出实现

**说明**：Renderer 不直接访问 Python 后端，统一通过 `preload` 暴露的 API 由 Main 进程代理请求，并在 Main 层附加 `X-Local-Token`。  

**后端（FastAPI）**：
```python
@router.post("/generation/stream")
async def generate_stream(request: GenerationRequest):
    async def event_generator():
        try:
            # 检索阶段
            yield f"data: {json.dumps({'type': 'status', 'message': '检索中...'})}\n\n"
            context = await retrieval_service.search(request.query)
            
            # 生成阶段
            yield f"data: {json.dumps({'type': 'status', 'message': '生成中...'})}\n\n"
            
            async for chunk in llm_service.chat_stream(prompt):
                yield f"data: {json.dumps({'type': 'chunk', 'content': chunk})}\n\n"
            
            yield f"data: {json.dumps({'type': 'done', 'sources': context})}\n\n"
        except Exception as e:
            yield f"data: {json.dumps({'type': 'error', 'message': str(e)})}\n\n"
    
    return StreamingResponse(event_generator(), media_type="text/event-stream")

@router.post("/generation/stop")
async def stop_generation(request: StopRequest):
    cancel_manager.cancel(request.request_id)
    return {"ok": True}
```

**前端（Vue 3）**：
```typescript
async function streamGenerate(query: string) {
  const requestId = crypto.randomUUID()
  window.api.startGeneration({ query, requestId })

  window.api.onGenerationChunk((chunk: string) => {
    content.value += chunk
  })

  window.api.onGenerationDone((payload: { sources: unknown }) => {
    sources.value = payload.sources
  })

  // 取消生成（用户点击“停止”）
  // await window.api.stopGeneration(requestId)
}
```

#### 3.3.4 质量与合规审查

**检查维度**：
- **缺引用**：关键事实/承诺缺失 `[@chunk_id]`  
- **弱引用**：证据片段与结论不匹配  
- **超承诺**：超出证据范围的绝对化表达  
- **风险条款**：招标要求中的负面偏离与风险项  
- **评分预估**：对照评分项输出加分/扣分建议  

**输出结构**（示例）：
```json
{
  "missing_citations": ["段落3"],
  "weak_support": ["技术指标A"],
  "overclaims": ["保证100%达标"],
  "risk_flags": ["付款周期过长"],
  "rewrite_suggestions": ["将“保证”改为“计划达到”"]
}
```

#### 3.3.5 版本管理与对比

- **草稿版本化**：按章节保存版本号，记录 `prompt_version` 与证据包  
- **对比与合并**：提供文本 diff + 引用差异对比，支持手动合并  
- **回放能力**：可追溯“证据包 → 草稿 → 审查”的全过程  

### 3.4 Word 文档生成引擎

#### 3.4.1 模板设计规范

**模板结构**：
```
templates/
├── base_template.docx              # 基础模板（样式、页眉页脚）
├── technical_proposal.docx         # 技术方案模板
├── commercial_proposal.docx        # 商务条款模板
└── pricing_table.docx              # 报价表模板
```

**模板语法（Jinja2 in Word）**：
```
使用 docxtpl 库，在 Word 中插入模板标签：

1. 变量替换：
   {{project_name}}
   {{company_name}}

2. 条件渲染：
   {% if has_certificate %}
   本公司具有 ISO9001 认证
   {% endif %}

3. 列表循环：
   {% for member in team_members %}
   - {{member.name}} ({{member.role}})
   {% endfor %}

4. 表格行循环：
   {% tr for item in pricing_items %}
   | {{item.name}} | {{item.price}} | {{item.quantity}} |
   {% endtr %}
```

#### 3.4.2 模板变量映射与校验

**模板变量映射器**：
1. 上传模板 → 自动解析 Jinja2 变量与循环块  
2. 用户为每个变量指定数据来源：手动输入 / 系统字段 / RAG 结果 / 固定值  
3. 保存映射规则并支持复用  

**映射示例**：
```json
{
  "project_name": "system.project_name",
  "team_members": "form.team_members",
  "pricing_table": "rag.pricing_items",
  "company_certificates": "evidence.certificates"
}
```

**校验策略**：
- 必填字段缺失直接阻断导出  
- 类型校验（列表/表格/图片）与默认值  
- 支持“预览填充结果”与批量测试  

#### 3.4.3 生成流程

```
用户点击"生成 Word"
    ↓
1. 前端收集表单数据
   └─→ { project_info, team_members, pricing_table, ... }
    ↓
2. 发送到后端 API
   └─→ POST /api/generation/word
    ↓
3. 后端渲染模板
   ├─→ 加载 .docx 模板文件
   ├─→ 使用 docxtpl 填充数据
   └─→ 保存到临时文件
    ↓
4. 返回文件下载链接
   └─→ 前端自动下载到本地
```

**错误处理**：
- 模板标签与数据不匹配 → 返回具体错误字段名
- 表格数据格式错误 → 返回行号和错误类型
- 图片插入失败 → 降级为文本描述

---

## 四、数据模型设计

### 4.1 关系型数据（SQLite）

**核心实体**：

```sql
-- 项目表
CREATE TABLE projects (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    rfp_doc_id TEXT,                      -- 关联招标文件
    status TEXT DEFAULT 'active',
    metadata JSON,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 文档表
CREATE TABLE documents (
    id TEXT PRIMARY KEY,                  -- UUID
    project_id TEXT,                      -- 可为空（公共知识库）
    name TEXT NOT NULL,                   -- 文件名
    file_path TEXT NOT NULL,              -- 原始文件路径
    file_hash TEXT NOT NULL,              -- SHA256 哈希（去重）
    file_size INTEGER,                    -- 文件大小（字节）
    category TEXT,                        -- 分类（技术文档/商务文档/案例）
    status TEXT DEFAULT 'processing',     -- 状态：processing/ready/failed
    total_chunks INTEGER,                 -- 总分块数
    metadata JSON,                        -- 扩展元数据
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 合规矩阵 / 需求条款
CREATE TABLE requirements (
    id TEXT PRIMARY KEY,
    project_id TEXT NOT NULL,
    section TEXT,
    requirement_text TEXT NOT NULL,
    score_weight REAL,
    risk_level TEXT,                      -- high/medium/low
    status TEXT DEFAULT 'open',
    source_chunk_ids JSON,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Query Pack
CREATE TABLE query_packs (
    id TEXT PRIMARY KEY,
    requirement_id TEXT NOT NULL,
    queries JSON,
    must_have_evidence JSON,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Evidence Pack
CREATE TABLE evidence_items (
    id TEXT PRIMARY KEY,
    requirement_id TEXT,
    chunk_id TEXT NOT NULL,
    doc_id TEXT NOT NULL,
    score REAL,
    tags JSON,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 草稿版本
CREATE TABLE drafts (
    id TEXT PRIMARY KEY,
    project_id TEXT NOT NULL,
    section TEXT NOT NULL,
    version INTEGER NOT NULL,
    content TEXT NOT NULL,
    citations JSON,
    prompt_version TEXT,
    status TEXT DEFAULT 'draft',          -- draft/reviewed/final
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 审查报告
CREATE TABLE review_reports (
    id TEXT PRIMARY KEY,
    draft_id TEXT NOT NULL,
    missing_citations JSON,
    weak_support JSON,
    overclaims JSON,
    risk_flags JSON,
    suggestions JSON,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 模板与映射
CREATE TABLE templates (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    file_path TEXT NOT NULL,
    schema JSON,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE template_mappings (
    id TEXT PRIMARY KEY,
    template_id TEXT NOT NULL,
    mapping JSON NOT NULL,
    validation_rules JSON,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 生成任务表
CREATE TABLE generation_tasks (
    id TEXT PRIMARY KEY,
    project_id TEXT,
    draft_id TEXT,
    task_type TEXT NOT NULL,              -- technical/commercial/pricing/review
    stage TEXT,                           -- parse/plan/draft/review/export
    status TEXT DEFAULT 'pending',        -- pending/running/completed/failed
    input_params JSON,                    -- 输入参数
    prompt_version TEXT,
    evidence_refs JSON,                   -- 证据引用列表
    output_content TEXT,                  -- 生成结果
    citations JSON,                       -- 引用映射
    tokens_used INTEGER,                  -- 消耗的 token 数
    duration_seconds REAL,                -- 耗时（秒）
    error_message TEXT,                   -- 错误信息
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 用户配置表
CREATE TABLE user_settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_documents_project ON documents(project_id);
CREATE INDEX idx_documents_category ON documents(category);
CREATE INDEX idx_documents_status ON documents(status);
CREATE INDEX idx_requirements_project ON requirements(project_id);
CREATE INDEX idx_drafts_project ON drafts(project_id);
CREATE INDEX idx_tasks_status ON generation_tasks(status);
CREATE INDEX idx_tasks_created ON generation_tasks(created_at DESC);
```

### 4.2 向量数据（LanceDB）

**Schema 定义**：
```python
from lancedb.pydantic import LanceModel, Vector

class DocumentChunk(LanceModel):
    # 主键
    id: str                                # chunk_uuid
    
    # 文档关联
    doc_id: str                            # 关联 documents 表
    doc_name: str                          # 文档名称（冗余，便于检索展示）
    
    # 内容
    text: str                              # 原始文本内容
    vector: Vector(1536)                   # Embedding 向量
    text_hash: str                         # 内容哈希（去重/缓存）

    # 位置信息
    chunk_index: int                       # 分块序号
    page_number: Optional[int]             # 页码（如果可提取）
    section_title: Optional[str]           # 章节标题
    parent_id: Optional[str]               # 父级片段（Parent Retriever）
    tokens: Optional[int]                  # 估算 token 数

    # 元数据
    category: str                          # 分类（继承自 document）
    source_type: Optional[str]             # rfp/history/template
    metadata: dict                         # 扩展元数据
    
    # 时间戳
    created_at: datetime
```

### 4.3 数据一致性保障

**导入事务**：
```python
async def import_document(file_path: str):
    async with db.transaction():
        # 1. 插入文档记录（status=processing）
        doc_id = await db.insert_document(...)
        
        try:
            # 2. 解析和分块
            chunks = await parser.parse(file_path)
            
            # 3. 生成向量
            vectors = await embedding_service.batch_encode([c.text for c in chunks])
            
            # 4. 存储向量到 LanceDB
            await lancedb.add_chunks(doc_id, chunks, vectors)
            
            # 5. 更新文档状态（status=ready）
            await db.update_document_status(doc_id, 'ready', total_chunks=len(chunks))
            
        except Exception as e:
            # 6. 失败回滚
            await db.update_document_status(doc_id, 'failed', error=str(e))
            await lancedb.delete_by_doc(doc_id)  # 清理向量数据
            raise
```

**删除级联**：
```python
async def delete_document(doc_id: str):
    # 1. 删除向量数据
    await lancedb.delete_by_doc(doc_id)
    
    # 2. 删除元数据
    await sqlite_db.delete_document(doc_id)
    
    # 3. 删除原始文件（可选保留）
    file_path = await sqlite_db.get_document_path(doc_id)
    os.remove(file_path)
```

### 4.4 本地存储路径与备份恢复

**路径规范**：
- Windows: `%APPDATA%\\BidCopilot\\`
- macOS: `~/Library/Application Support/BidCopilot/`
- Linux: `~/.local/share/BidCopilot/`

**目录结构建议**：
```
data/
  db.sqlite
  lancedb/
files/           # 原始文档
templates/       # Word 模板
cache/           # 临时缓存
logs/
```

**备份与恢复**：
- 一键导出：SQLite + LanceDB + 模板与映射 + 版本号清单 + 校验和  
- 导入时校验版本兼容，不兼容则提示“只读导入/升级迁移”  

---

## 五、非功能需求实现

### 5.1 安全架构

#### 5.1.1 密钥管理

**存储方案**：
```
Windows: Windows Credential Manager (win32cred)
macOS: Keychain Access (keyring)
Linux: Secret Service API (gnome-keyring / kwallet)

统一封装：使用 Python keyring 库
```

**实现**：
```python
import keyring

# 存储（首次配置）
keyring.set_password("BidCopilot", "openai_api_key", user_input_key)

# 读取（启动时）
api_key = keyring.get_password("BidCopilot", "openai_api_key")
if not api_key:
    # 提示用户配置
    show_settings_dialog()
```

**补充策略**：
- 若系统无可用 keyring，主进程使用 Electron `safeStorage` 加密保存  
- 密钥仅在内存中传递给 Python 子进程，不落盘、不写日志  

**访问控制**：
- 渲染进程：无法访问密钥，通过 IPC 请求主进程代理
- 主进程：启动时读取密钥，通过环境变量传递给 Python 子进程
- Python 后端：内存中持有密钥，不写入日志和文件

#### 5.1.2 数据隐私

**最小外传原则**：
```
发送给云端 LLM 的内容：
✅ 允许：
   - 用户当前输入的需求描述
   - 检索到的 Top-5 相关片段（约 3000 tokens）
   - 系统提示词和任务指令

❌ 禁止：
   - 完整文档原文
   - 用户的历史对话记录
   - 文档元数据（文件名、路径）
   - 用户配置和 API 密钥
```

**脱敏处理**（可选）：
```python
def redact_sensitive_info(text: str) -> str:
    """脱敏敏感信息"""
    # 手机号
    text = re.sub(r'1[3-9]\d{9}', '***********', text)
    # 身份证号
    text = re.sub(r'\d{17}[\dXx]', '******************', text)
    # 邮箱
    text = re.sub(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b', '***@***.com', text)
    return text
```

### 5.2 性能优化策略

#### 5.2.1 前端性能优化

**关键指标**：
- 首屏渲染 < 2s
- 交互响应 < 100ms
- 大列表滚动 60 FPS

**优化手段**：

1. **路由懒加载**：
```typescript
const routes = [
  {
    path: '/documents',
    component: () => import('@/views/Documents.vue')
  }
]
```

2. **虚拟列表**（大量文档时）：
```vue
<template>
  <VirtualList
    :data="documents"
    :item-height="80"
    :buffer="5"
  >
    <template #item="{ item }">
      <DocumentCard :doc="item" />
    </template>
  </VirtualList>
</template>
```

3. **Computed 缓存**：
```typescript
const filteredDocs = computed(() => {
  return documents.value.filter(d => d.name.includes(searchQuery.value))
})
```

#### 5.2.2 后端性能优化

**关键指标**：
- 检索 P95 < 300ms
- 生成首 token < 3s
- 并发支持 10 QPS

**优化手段**：

1. **连接池复用**：
```python
# SQLite 连接池
engine = create_async_engine(
    DATABASE_URL,
    pool_size=5,
    max_overflow=10,
    pool_pre_ping=True
)

# HTTP 客户端连接池
http_client = httpx.AsyncClient(
    limits=httpx.Limits(max_connections=100, max_keepalive_connections=20)
)
```

2. **LRU 缓存**：
```python
from functools import lru_cache

@lru_cache(maxsize=1000)
def get_embedding_cached(text: str) -> List[float]:
    """缓存 Embedding 结果"""
    return embedding_model.encode(text)
```

3. **批量操作**：
```python
# 批量 Embedding（减少 API 调用）
async def batch_embed(texts: List[str], batch_size: int = 100):
    results = []
    for i in range(0, len(texts), batch_size):
        batch = texts[i:i+batch_size]
        batch_vectors = await openai_client.embeddings.create(
            model="text-embedding-3-small",
            input=batch
        )
        results.extend([r.embedding for r in batch_vectors.data])
    return results
```

### 5.3 可观测性

#### 5.3.1 日志体系

**分级策略**：
```
DEBUG: 详细调试信息（仅开发环境）
INFO: 关键业务流程（文档导入成功、生成任务完成）
WARNING: 可恢复的异常（重试、降级）
ERROR: 需要人工介入的错误（API 调用失败、数据损坏）
```

**结构化日志**：
```python
import structlog

logger = structlog.get_logger()

logger.info(
    "document_imported",
    doc_id=doc.id,
    doc_name=doc.name,
    chunks=len(chunks),
    duration_ms=duration
)
```

**日志存储**：
```
日志位置：
- Windows: %APPDATA%\BidCopilot\logs\
- macOS: ~/Library/Logs/BidCopilot/
- Linux: ~/.local/share/BidCopilot/logs/

文件命名：
- app.log (主进程日志)
- backend.log (Python 后端日志)
- backend.log.1 (轮转备份)

轮转策略：
- 单文件最大 10MB
- 保留最近 7 天
- 超过 100MB 压缩归档
```

#### 5.3.2 性能监控

**关键指标采集**：
```python
from prometheus_client import Counter, Histogram

# 请求计数
request_count = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint'])

# 响应时间
request_duration = Histogram('http_request_duration_seconds', 'HTTP request latency')

@app.middleware("http")
async def monitor_middleware(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    duration = time.time() - start_time
    
    request_count.labels(method=request.method, endpoint=request.url.path).inc()
    request_duration.observe(duration)
    
    return response
```

**前端监控**（可选）：
```typescript
// 性能监控
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.entryType === 'navigation') {
      console.log('页面加载时间:', entry.loadEventEnd - entry.fetchStart)
    }
  }
})
observer.observe({ entryTypes: ['navigation'] })
```

### 5.4 离线与资源受限模式

**无网降级**：
- 检测 OpenAI-compatible API 不可用 → 切换至本地模型（如 Ollama）  
- 或仅启用检索/引用模式（不生成正文）  
- UI 明示“离线模式”并提示功能差异  

**资源受限**：
- 后台任务支持暂停/恢复，限制并发与批量大小  
- 高 CPU/内存时降低检索频率或延迟向量写入  

---

## 六、打包与部署

### 6.1 跨平台打包策略

#### 6.1.1 Python 后端打包

**PyInstaller 配置**（`backend/build.spec`）：
```python
# -*- mode: python ; coding: utf-8 -*-

block_cipher = None

a = Analysis(
    ['app/main.py'],
    pathex=[],
    binaries=[],
    datas=[
        ('prompts', 'prompts'),        # 提示词模板
        ('templates', 'templates'),    # Word 模板
    ],
    hiddenimports=[
        'lancedb',
        'pyarrow',
        'uvicorn',
        'fastapi',
    ],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[
        'matplotlib',
        'pandas',
        'jupyter',
        'IPython',
        'pytest',
    ],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='backend',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console=False,  # Windows 下隐藏控制台
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name='backend',
)
```

**构建命令**：
```bash
# 安装依赖
pip install pyinstaller

# 构建（目录模式）
pyinstaller backend/build.spec --distpath dist/backend --workpath build/backend

# 预期产物
dist/backend/
├── backend.exe (or backend on Unix)
├── _internal/
│   ├── Python DLLs
│   ├── site-packages
│   └── ...
├── prompts/
└── templates/
```

#### 6.1.2 Electron 前端打包

**electron-builder 配置**（`electron-builder.yml`）：
```yaml
appId: com.bidcopilot.app
productName: BidCopilot
copyright: Copyright © 2024

directories:
  output: release
  buildResources: build

files:
  - dist/**/*
  - dist-electron/**/*
  - package.json
  - "!**/.vscode/*"
  - "!src/*"
  - "!electron/*"
  - "!node_modules/**/*"

extraResources:
  - from: dist/backend
    to: backend
    filter:
      - "**/*"

win:
  target:
    - nsis
  icon: build/icon.ico
  artifactName: ${productName}-${version}-win-${arch}.${ext}
  
nsis:
  oneClick: false
  allowToChangeInstallationDirectory: true
  perMachine: true
  deleteAppDataOnUninstall: true

mac:
  target:
    - dmg
  icon: build/icon.icns
  category: public.app-category.productivity
  hardenedRuntime: true
  gatekeeperAssess: false
  entitlements: build/entitlements.mac.plist
  entitlementsInherit: build/entitlements.mac.plist

linux:
  target:
    - AppImage
  icon: build/icon.png
  category: Office
```

**主进程 Python 启动逻辑**：
```typescript
// electron/utils/python.ts
import { spawn } from 'child_process'
import { app } from 'electron'
import path from 'path'

export class PythonBackend {
  private process: ChildProcess | null = null
  private port: number = 0
  private token: string = ''
  
  async start(): Promise<{ port: number; token: string }> {
    const isProd = app.isPackaged
    const backendPath = isProd
      ? path.join(process.resourcesPath, 'backend', 'backend')
      : path.join(__dirname, '../../backend/main.py')
    const command = isProd ? backendPath : 'python'
    const args = isProd ? ['--port', '0'] : [backendPath, '--port', '0']
    
    return new Promise((resolve, reject) => {
      this.process = spawn(command, args, {
        stdio: 'pipe'
      })
      
      this.process.stdout?.on('data', (data) => {
        const output = data.toString()
        // 解析: {"port": 8765, "token": "xxx"}
        const match = output.match(/\{.*\}/)
        if (match) {
          const info = JSON.parse(match[0])
          this.port = info.port
          this.token = info.token
          resolve(info)
        }
      })
      
      this.process.on('error', reject)
      
      // 5s 超时
      setTimeout(() => reject(new Error('Backend start timeout')), 5000)
    })
  }
  
  async stop(): Promise<void> {
    if (this.process) {
      this.process.kill('SIGTERM')
      await new Promise(resolve => setTimeout(resolve, 3000))
      if (this.process?.exitCode === null) {
        this.process.kill('SIGKILL')
      }
    }
  }
}
```

### 6.2 自动更新机制

**架构**：
```
用户启动应用
    ↓
主进程检查更新（后台）
    ↓
请求更新服务器: GET /api/version/latest
    ↓
对比本地版本
    ↓
有新版本 → 下载更新包（增量或全量）
           ↓
           校验签名（防篡改）
           ↓
           提示用户重启安装
    ↓
无新版本 → 正常启动
```

**配置**（`package.json`）：
```json
{
  "build": {
    "publish": {
      "provider": "generic",
      "url": "https://updates.yourdomain.com"
    }
  }
}
```

**实现**（主进程）：
```typescript
import { autoUpdater } from 'electron-updater'

autoUpdater.setFeedURL({
  provider: 'generic',
  url: 'https://updates.yourdomain.com'
})

autoUpdater.checkForUpdatesAndNotify()

autoUpdater.on('update-available', (info) => {
  // 显示"有新版本"通知
})

autoUpdater.on('download-progress', (progress) => {
  // 显示下载进度
})

autoUpdater.on('update-downloaded', () => {
  // 提示用户重启安装
  dialog.showMessageBox({
    type: 'info',
    title: '更新就绪',
    message: '新版本已下载，是否立即重启安装?',
    buttons: ['立即重启', '稍后']
  }).then((result) => {
    if (result.response === 0) {
      autoUpdater.quitAndInstall()
    }
  })
})
```

---

## 七、架构演进路线图

### 7.1 MVP 阶段（v0.1 - Week 1-4）

**目标**：验证核心价值，打通完整链路

**功能范围**：
- ✅ 项目工作台 + 文档导入（PDF/Word）
- ✅ RFP 解析 + 合规矩阵生成
- ✅ 证据检索 + 引用展示
- ✅ 章节草拟（技术方案为主）+ 流式输出
- ✅ 引用/合规基础校验
- ✅ Word 模板变量映射 + 导出

**技术债务（可接受）**：
- 无自动更新
- 无版本对比/回放
- 错误处理简单
- 性能未优化

### 7.2 Beta 阶段（v0.5 - Week 5-8）

**目标**：增强稳定性和用户体验

**功能增强**：
- ✅ 混合检索：向量 + BM25 + 重排序
- ✅ Query Pack 与 Claim Plan
- ✅ 版本对比与合并
- ✅ 数据备份：一键导出/导入
- ✅ 打包优化：单击安装、Python 后端自动启动
- ✅ 错误恢复：任务队列、断点续传

**质量提升**：
- 单元测试覆盖率 > 60%
- 核心流程 E2E 测试
- 性能基准测试

### 7.3 正式版（v1.0 - Week 9-12）

**目标**：生产可用

**功能完善**：
- ✅ 自动更新
- ✅ 多模型支持：OpenAI / Azure OpenAI / 本地模型
- ✅ 提示词管理：可视化编辑、A/B 测试
- ✅ 多轮对话上下文管理（项目级会话）
- ✅ 批量生成与任务队列
- ✅ 审计日志：导出诊断包
- ✅ 国际化：中英文

**质量标准**：
- 测试覆盖率 > 80%
- 性能指标达标（所有 P0 指标满足）
- 安全审计通过
- 用户文档完善

### 7.4 未来演进（v2.0+）

**可选方向**：
1. **协作功能**：多人共同编辑标书（需引入云端存储）
2. **本地模型**：集成 Ollama 支持离线运行
3. **插件系统**：支持自定义提示词插件和模板插件
4. **智能审阅**：自动检测标书合规性、逻辑一致性
5. **移动端**：iOS/Android 轻量版（仅查看和审阅）

---

## 八、总结与关键决策矩阵

### 8.1 架构决策对照表

| 决策点 | OpenAI 建议 | Gemini 建议 | Claude 建议 | 最终方案 | 理由 |
|--------|-------------|-------------|-------------|----------|------|
| **进程通信** | stdio JSON-RPC | HTTP REST | HTTP REST | **HTTP REST** | 调试友好、生态成熟 |
| **向量数据库** | sqlite-vec/LanceDB | LanceDB/Chroma | LanceDB | **LanceDB** | 桌面友好、易打包 |
| **Python 打包** | 单可执行 | PyInstaller | PyInstaller 目录 | **PyInstaller 目录** | 启动快、易更新 |
| **前端状态管理** | 最小化状态 | - | Pinia | **Pinia** | Vue 3 生态标准 |
| **提示词管理** | 模板化+版本控制 | 内嵌字符串 | 配置文件 | **模板化+版本控制** | 可迭代、可追溯 |
| **检索策略** | 向量检索 | 混合检索 | 向量检索 | **混合检索** | 提升召回率 |
| **安全边界** | 明确分层 | 提及 | 全面覆盖 | **三层分层** | 最小权限原则 |

### 8.2 核心设计原则重申

1. **安全第一**：密钥不进渲染层、数据不外传、IPC 需鉴权
2. **性能可量化**：所有 NFR 有明确指标和测量方法
3. **架构可演进**：模块化设计、适配器模式、版本兼容
4. **工程可落地**：避免过度设计、优先 MVP、持续迭代

### 8.3 风险与缓解

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| Python 打包体积过大 | 中 | 高 | 极致剪裁、分层下载 |
| 向量检索性能不足 | 高 | 中 | LanceDB 索引优化、缓存策略 |
| Electron 启动慢 | 中 | 中 | 懒加载、后台预热 |
| 云端 API 不稳定 | 高 | 中 | 重试机制、本地缓存、降级方案 |
| 用户数据泄漏 | 高 | 低 | 加密存储、最小外传、审计日志 |

---

## 附录：参考资料与工具链

### A. 技术栈版本锁定

**前端**：
- Electron: ^28.0.0
- Vue: ^3.4.0
- TypeScript: ^5.3.0
- Vite: ^5.0.0
- Element Plus: ^2.5.0
- Pinia: ^2.1.0

**后端**：
- Python: 3.11+
- FastAPI: ^0.110.0
- LanceDB: ^0.5.0
- OpenAI SDK: ^1.12.0
- SQLAlchemy: ^2.0.0
- docxtpl: ^0.16.7

**工具**：
- PyInstaller: ^6.0.0
- electron-builder: ^24.9.0

### B. 关键文档

- [OpenAI Embedding Best Practices](https://platform.openai.com/docs/guides/embeddings)
- [LanceDB Documentation](https://lancedb.github.io/lancedb/)
- [Electron Security Guidelines](https://www.electronjs.org/docs/latest/tutorial/security)
- [FastAPI Best Practices](https://fastapi.tiangolo.com/advanced/)
- [docxtpl Template Guide](https://docxtpl.readthedocs.io/)

### C. 架构评审清单

在开始编码前，确保以下问题已回答：

- [ ] 信任边界是否清晰？
- [ ] 性能指标是否量化？
- [ ] 数据一致性如何保障？
- [ ] 错误恢复策略是否完善?
- [ ] 打包产物体积是否可接受？
- [ ] 自动更新机制是否可靠？
- [ ] 安全风险是否已评估？
- [ ] 测试策略是否明确？

---

**文档版本**: v1.0  
**最后更新**: 2026-01-29  
**维护者**: 架构团队  
**审阅状态**: ✅ 已通过初步评审
